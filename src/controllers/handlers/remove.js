import { Logger } from "@src/core/Logger";
import { Runtime } from "@src/core/Runtime";
import { EventBus } from "@src/core/EventBus";
import { DiagramQL } from "@src/data/DiagramQL";
import { DeleteVariables } from "@src/ui/structure/Messages/DeleteVariables";

export const remove = () => {
  const runtime = new Runtime();
  const eventBus = new EventBus();
  const engine = runtime.get("objects.engine");

  const dql = new DiagramQL(engine.model);

  // Get only the nodes that can actually be removed
  const collection = engine.selection.collection.clone();
  collection.reset(collection.filter(node => node.prop("removable")));

  // "collection" might contain groups; if this is the case, the collection
  // won't contain the embedded elements of the groups. We must iterate over
  // each group and get it's children.
  const new_collection = [];
  while(collection.length > 0) {
    const model = collection.shift();

    if(model.isGroup()) {
      collection.push(...model.getEmbeddedCells({ deep: true }));
    }

    new_collection.push(model);
  }

  const selected_ids = new_collection.map(model => model.id);
  const outputs = [];
  new_collection.forEach(model => {
    Object.values(
      model.prop("data/settings/outputs") || {}
    )?.forEach(output => {

      let dependant_node_ids = dql.query(
        dql.nodesUsing({
          parent: model.id,
          varname: output.value,
        })
      )?.map(
        obj => obj.__node_id
      ) || [];

      // Ignore nodes that are selected, as we'll remove them anyways.
      // We want to do this because the user might select several nodes.
      // The second one might depend on an output variable generated by the
      // first one. If this is the case, we don't want to ask the user if he/she
      // would like remove orphan references in the second node, as we'll
      // remove it anyways.
      dependant_node_ids = dependant_node_ids.filter(
        node_id => !selected_ids.includes(node_id)
      );

      if(dependant_node_ids.length > 0) {
        outputs.push({
          node_id: model.id,
          varname: output.value,
          dependant_node_ids,
        });
      }
    });
  });

  if(outputs.length > 0) {

    eventBus.publish("OpenDialog", {
      title: "Delete variable references?",
      body: <DeleteVariables outputs={outputs} />,
      cancel: () => {
        // noop
      },
      no: () => {
        _finish_deleting();
      },
      yes: () => {
        const cm = runtime.get("objects.commandManager");

        cm.initBatchCommand();

        // Delete references
        outputs.forEach(output => {
          dql.query(
            dql.bulkDeleteReference({
              node_ids: output.dependant_node_ids,
              varname: output.varname,
            })
          );
        });

        _finish_deleting();

        cm.storeBatchCommand();
      },
    });

  } else {
    _finish_deleting();
  }
}

const _finish_deleting = () => {
  const logger = new Logger();
  const runtime = new Runtime();
  const engine = runtime.get("objects.engine");

  // Delete selected items
  logger.debug("Deleting selected elements...");

  const { collection } = engine.selection;
  collection.filter(node => node.prop("removable")).forEach(model => model.remove());

  collection.reset([]);
}
